# 빅오 표기법(Big O Notation)

## 📌 요약
- 알고리즘의 성능을 분석하기 위해 빅오 표기법을 사용한다.
- 빅오 표기법을 사용하면 알고리즘의 시간 또는 공간 복잡성을 높은 수준으로 이해할 수 있다.
- 빅오 표기법은 정확도에는 관심이 없고 일반적인 추세(선형? 이차? 상수?)에만 관심이 있다.
- 시간 또는 공간 복잡도(Big O로 측정)는 알고리즘에 따라 달라지는 것이지, 알고리즘을 실행하는 하드웨어에 따라 달라지지 않는다.

<br>
<br>

## 📌 빅오 표기법은 왜 필요한가?

어떤 문제에 두 가지 해결법이 있다고 생각해보자.

두 가지 해결법 모두 정답이지만, 서로 다르다. 매개변수와 이름 정도의 차이가 아니라 문제를 접근하는 방식 자체가 다른 것이다. 하나는 루프를 사용하고, 다른 하나는 리스트나 문자열을 이용해서 똑같은 문제를 해결한다고 했을 때, *두 해결법 중에 어떤 것이 더 나은 방법일까?*

이것이 빅오의 핵심이다.

일종의 시스템으로, **여러가지 코드를 일반화하여 서로 비교하고 성능을 평가하는 방법**이다.

> 문자열 s가 매개변수로 주어졌을 때, 이것을 뒤집어서 출력해보세요.
> 

[How do you reverse a string in-place?](https://stackoverflow.com/questions/958908/how-do-you-reverse-a-string-in-place)

위의 스택오버플로우 답변에서 볼 수 있듯, 이 문제를 해결할 수 있는 방법들은 정말 다양하다.

이 다양한 방법들의 성능을 단지 ‘최고’, ‘좋음’, ‘괜찮음’, ‘그저그럼’, ‘최악’ 정도가 아니라 정확한 ‘숫자’를 통해 나타낼 수 있다. 그리고 코드 성능에 대해 평가할 때는 정확한 전문용어를 사용하는 것이 중요하다.

<br>
<br>

## 📌 코드 실행 시간 측정하기

1부터 n까지 합을 구하는 문제에 대한 해결 방법으로 다음 두 가지가 있다.

```jsx
function addUpTo1(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
```

```jsx
function addUpTo2(n) {
  return n * (n + 1) / 2;
}
```

### 두 가지 해결 방법 중 더 ‘낫다’는 것은 어떤 의미일까?

- 더 빠르다. ✅ 먼저 이 방법을 살펴볼 수 있겠다.
- 메모리를 더 적게 사용한다.
- 코드의 길이가 더 짧고 이해하기 쉽다.

<br>

### 코드 실행시간 측정

코드 실행시간을 측정할 수 있는 가장 쉬운 방법은 **내장 타이머 함수**를 이용하는 것이다.

```jsx
// add1.js
function addUpTo1(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}

let t1 = performance.now();
addUpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
```

```jsx
// add2.js
function addUpTo2(n) {
  return n * (n + 1) / 2;
}

let t1 = performance.now();
addUpTo2(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
```

![image](https://github.com/xoxojw/algorithm/assets/124491335/30cce21a-677c-4f42-9d8b-f017d0885200)

<br>

### 시간 측정법의 문제점

- 기기와 환경에 따라 측정 시간이나 해결 방법간의 시간 차이가 달라질 수 있다.
- 같은 기기에서도 코드를 실행할 때마다 조금씩 시간이 달라진다.
- 매우 짧은 시간에 처리가 끝나는 알고리즘의 경우에는 정확하게 측정하기가 어렵다.

<br>

### ✅ **컴퓨터가 처리해야하는 연산의 개수를 세면 된다.**

> 컴퓨터가 처리하는 연산의 개수는 어떤 기기에서도 달라지지 않는다.

<br>
<br>

## 📌 빅오 표기법이란?

> 함수의 입력값 크기가 증가함에 따라 함수 실행 시간이 어떻게 변하는지 그 관계를 측정하는 것

주어진 알고리즘이 입력 크기에 따라 어떻게 실행 시간이 증가하는지를 나타낸다. 시간 복잡도에 미미한 영향을 주는 값들은 무시하고 전체적인 추세를 본다는 점이 특징이다.

특히 가장 높은 실행시간 값, 그러니까 **최악의 실행시간**을 표기하는 데에 주로 사용된다.

- 알고리즘 실행 시간이 어떤 함수 f(n)에 비례할 때, 시간 복잡도를 O(f(n))으로 나타낸다.
    
    > n 입력값, f(n) 실행 시간, O(f(n)) 알고리즘 실행 시간의 상한값
    > 
    - `f(n) = n`
        - 실행 시간이 선형함수 형태로 증가한다. (n과 함께 증가)
    - `f(n) = n²`
        - 실행 시간이 이차함수 형태로 증가한다. (n과 함께 증가)
    - `f(n) = 1`
        - 실행 시간이 상수함수 형태이다. (실행 시간이 n값에 영향을 받지 않음)
    - `f(n)` : f(n) could be something entirely different!

![image](https://github.com/xoxojw/algorithm/assets/124491335/fef29f90-3573-4e28-96b3-a3951eae6f79)

<br>

📝 시간 복잡도 시각화해보기

[Big O Introduction](https://rithmschool.github.io/function-timer-demo/)

<br>

### 📌 빅오 표기법의 단순화

- **상수항과 낮은 차수의 항은 무시**하여 알고리즘의 성능을 간결하게 표현한다.
    - ex. 알고리즘 실행 시간 O(f(n))이 3n² + 5n + 2라면, 이 알고리즘의 빅오 표기법은 O(n²)이다. 상수항과 낮은 차수의 항이 무시되었기 때문이다.

1. 컴퓨터의 산술 연산은 상수이다.
	- 컴퓨터가 2+2를 처리하는 시간과 100만+2를 처리하는 시간은 비슷함
2. 변수 할당도 상수이다.
	- `x = 1000`과 `x = 20000`, `x=1000000`을 처리하는 것은 모두 비슷함
3. 인덱스로 배열 요소에 접근하는 것, key로 객체에 접근하는 것 모두 상수이다.
4. 반복문에서의 복잡도는 `반복문의 길이*반복문 내부의 복잡도` 이다.

<br>
<br>

## 📌 공간 복잡도
> 알고리즘에서 코드를 실행하려면 얼마나 더 많은 메모리를 할당해야 할까?

1. 대부분의 원시값(booleans, numbers, undefined, null)은 불변 공간이다.
	- 숫자가 1이든 1000이든 같은 공간을 차지하고 있음
2. 문자열은 `O(n)` 공간이 필요하다.
	- 50자 문자열은 1자 문자열보다 50배 더 많은 공간을 차지
3. 참조값도 `O(n)`을 차지한다.
	- 배열은 배열의 길이에, 객체는 키의 개수에 비례함

<br>

### 예시
```js
function sum(arr) {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
	total += arr[i];
  }
  return total;
} // 😑 O(n) / ✅ O(1) space
```
공간으로 할당되는 것은 숫자타입인 `total`과 `i`이다. `total`과 `i`는 모두 원시값이므로 위 함수의 공간 복잡도는 `O(1)`이다.

```js
function double(arr) {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    newArr.push(2 * arr[i]);
  }
  return newArr;
} // O(n) space
```
`newArr`은 처음에 무조건 공간을 할당하고, 그 후로는 i의 크기에 비례해서 배열의 길이가 길어진다.

<br>

## 📌 로그(logarithm)

> **지수함수의 역함수**
> 나눗셈과 곱셈이 짝인 것처럼, 로그함수와 지수함수는 짝이다.

```
log₂(value) = 2^exponent = value
```

주로 이진 로그(`log₂`)를 많이 사용하는데, 귀찮으니까 여기에서는 밑이 2인 경우에는 밑을 생략하고 `log`로 쓰자! *원래는 십진 로그에서 생략했던 것 같아..*

![](https://github.com/xoxojw/algorithm/assets/124491335/8c8f5e2e-0e46-4bc8-b788-ae36a0589dc0)

그래프에서도 볼 수 있듯, 알고리즘이 `logn` 시간 복잡도를 갖고 있다면 좋은 것이다.

- 특정 검색 알고리즘에는 로그 시간 복잡도가 있음
- 효율적인 정렬 알고리즘에는 로그가 포함
- 재귀는 때때로 로그 공간 복잡도를 포함

<br>
<br>
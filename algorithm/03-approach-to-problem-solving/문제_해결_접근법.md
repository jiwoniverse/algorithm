# 문제 해결 접근법

## 📌 순서

1. Understand the problem
2. Explore concrete examples
3. Break it down
4. Solve/Simplify
5. Look back and refactor

<br>

## 1단계: 문제의 이해

1. '문제를 내 방식대로 다시 생각할 수 있는가?'를 생각해보기
2. 문제에 어떤 input값을 넣어야 하는지?
3. 솔루션에서 어떤 output값이 결과로 나와야 하는지?
4. output들이 input들로부터 결정될 수 있는지?

   - 문제를 해결하는데 충분한 정보가 주어졌는지?

5. 문제의 일부인 데이터에 어떻게 레이블링을 해야할 것인지?

<br>

## 2단계: 구체적 예제들

1. 간단한 예제로 시작하기
2. 좀 더 복잡한 예제로 나아가기
3. 빈 input값의 예제로 살펴보기
4. 유효하지 않은 input값의 예제로 살펴보기

<br>

### 유저 스토리

> 애자일 방법론에서 사용되는 도구로, 사용자 관점에서 시스템이 어떻게 동작해야 하는지를 간단하게 서술한 것

형식

```css
As a [user type], I want to [goal] so that [reason].
```

예시 - 전자상거래 웹사이트

```css
As a customer, I want to be able to filter products by price so that I can find items within my budget.
```

- 사용자 중심: 사용자의 관점에서 작성
- 간결성: 간단하고 명확하게 요구사항을 서술
- 가치 중심: 사용자에게 가치를 제공하는 목표를 명시
- 대화의 시작점: 개발자와 이해관계자 간의 대화를 촉진하는 역할

<br>

### 단위 테스트

> 소프트웨어의 특정 부분(유닛)을 테스트하는 코드 <br>
> 보통 함수나 메서드와 같은 작은 코드 조각을 의미하며, 개발자가 작성한 코드가 예상대로 작동하는지 확인하는데 사용

- 자동화: 테스트를 자동으로 실행
- 독립성: 각 테스트는 독립적으로 실행되어야 함
  - 하나의 테스트가 실패하더라도 다른 테스트에는 영향을 미치지 않음
- 반복 가능성: 동일한 입력값에 대해 언제나 동일한 결과를 반환해야 함
- 작은 범위: 소프트웨어의 작은 단위를 테스트

```js
// math.js
function add(a, b) {
	return a + b;
}

module.exports = add;
```

```js
// math.test.js
const add = require("./math");

test("adds 1 + 2 to equal 3", () => {
	expect(add(1, 2)).toBe(3);
});

test("adds -1 + 1 to equal 0", () => {
	expect(add(-1, 1)).toBe(0);
});

test("adds -1 + -1 to equal -2", () => {
	expect(add(-1, -1)).toBe(-2);
});
```

- 테스트는 `Jest`를 설치하여 package.json 파일에 테스트 스크립트를 추가하고 `npm test`로 테스트를 수행할 수 있음

<br>

## 3단계: 세부 분석

- 문제를 해결하기 위한 단계들을 명확하게 작성해보기
  - 세세하게 모든 라인을 작성할 필요는 없고, 기본적인 구성 단계별로 작성
- 이를 통해 개념적인 문제나 오해하고 있는 부분을 이해하고 문제 해결을 위한 세부 단계를 파악할 수 있음

<br>

## 4단계: 해결 또는 단순화

<br>

## 5단계: 되돌아보기와 리팩토링

<br>

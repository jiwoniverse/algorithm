# 빅오 표기법(Big O Notation)

## 📌 빅오 표기법은 왜 필요한가?

어떤 문제에 두 가지 해결법이 있다고 생각해보자.

두 가지 해결법 모두 정답이지만, 서로 다르다. 매개변수와 이름 정도의 차이가 아니라 문제를 접근하는 방식 자체가 다른 것이다. 하나는 루프를 사용하고, 다른 하나는 리스트나 문자열을 이용해서 똑같은 문제를 해결한다고 했을 때, *두 해결법 중에 어떤 것이 더 나은 방법일까?*

이것이 빅오의 핵심이다.

일종의 시스템으로, **여러가지 코드를 일반화하여 서로 비교하고 성능을 평가하는 방법**이다.

> 문자열 s가 매개변수로 주어졌을 때, 이것을 뒤집어서 출력해보세요.
> 

[How do you reverse a string in-place?](https://stackoverflow.com/questions/958908/how-do-you-reverse-a-string-in-place)

위의 스택오버플로우 답변에서 볼 수 있듯, 이 문제를 해결할 수 있는 방법들은 정말 다양하다.

이 다양한 방법들의 성능을 단지 ‘최고’, ‘좋음’, ‘괜찮음’, ‘그저그럼’, ‘최악’ 정도가 아니라 정확한 ‘숫자’를 통해 나타낼 수 있다. 그리고 코드 성능에 대해 평가할 때는 정확한 전문용어를 사용하는 것이 중요하다.

<br>
<br>

## 📌 코드 실행 시간 측정하기

1부터 n까지 합을 구하는 문제에 대한 해결 방법으로 다음 두 가지가 있다.

```jsx
function addUpTo1(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
```

```jsx
function addUpTo2(n) {
  return n * (n + 1) / 2;
}
```

### 두 가지 해결 방법 중 더 ‘낫다’는 것은 어떤 의미일까?

- 더 빠르다. ✅ 먼저 이 방법을 살펴볼 수 있겠다.
- 메모리를 더 적게 사용한다.
- 코드의 길이가 더 짧고 이해하기 쉽다.

<br>

### 코드 실행시간 측정

코드 실행시간을 측정할 수 있는 가장 쉬운 방법은 **내장 타이머 함수**를 이용하는 것이다.

```jsx
// add1.js
function addUpTo1(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}

let t1 = performance.now();
addUpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
```

```jsx
// add2.js
function addUpTo2(n) {
  return n * (n + 1) / 2;
}

let t1 = performance.now();
addUpTo2(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
```

![image](https://github.com/xoxojw/algorithm/assets/124491335/30cce21a-677c-4f42-9d8b-f017d0885200)

<br>

### 시간 측정법의 문제점

- 기기와 환경에 따라 측정 시간이나 해결 방법간의 시간 차이가 달라질 수 있다.
- 같은 기기에서도 코드를 실행할 때마다 조금씩 시간이 달라진다.
- 매우 짧은 시간에 처리가 끝나는 알고리즘의 경우에는 정확하게 측정하기가 어렵다.

<br>

### ✅ **컴퓨터가 처리해야하는 연산의 개수를 세면 된다.**

> 컴퓨터가 처리하는 연산의 개수는 어떤 기기에서도 달라지지 않는다.

<br>
<br>

## 📌 빅오 표기법이란?

> 함수의 입력값 크기가 증가함에 따라 함수 실행 시간이 어떻게 변하는지 그 관계를 측정하는 것

주어진 알고리즘이 입력 크기에 따라 어떻게 실행 시간이 증가하는지를 나타낸다. 시간 복잡도에 미미한 영향을 주는 값들은 무시하고 전체적인 추세를 본다는 점이 특징이다.

특히 가장 높은 실행시간 값, 그러니까 **최악의 실행시간**을 표기하는 데에 주로 사용된다.

- 알고리즘 실행 시간이 어떤 함수 f(n)에 비례할 때, 시간 복잡도를 O(f(n))으로 나타낸다.
    
    > n 입력값, f(n) 실행 시간, O(f(n)) 알고리즘 실행 시간의 상한값
    > 
    - `f(n) = n`
        - 실행 시간이 선형함수 형태로 증가한다. (n과 함께 증가)
    - `f(n) = n²`
        - 실행 시간이 이차함수 형태로 증가한다. (n과 함께 증가)
    - `f(n) = 1`
        - 실행 시간이 상수함수 형태이다. (실행 시간이 n값에 영향을 받지 않음)
    - `f(n)` : f(n) could be something entirely different!

![image](https://github.com/xoxojw/algorithm/assets/124491335/fef29f90-3573-4e28-96b3-a3951eae6f79)

<br>

📝 시간 복잡도 시각화해보기

[Big O Introduction](https://rithmschool.github.io/function-timer-demo/)

<br>
<br>